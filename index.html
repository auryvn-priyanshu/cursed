<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOMAIN EXPANSION // virtual playground for sorceres by PRIYANSHU</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Yu Gothic', 'Segoe UI', sans-serif; color: white; }
        canvas { display: block; }
        
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
            padding-top: 6vh; z-index: 10;
        }

        .header-group { text-align: center; }
        .title {
            font-size: clamp(1.5rem, 5vw, 4rem); font-weight: 900; letter-spacing: 1.2rem;
            text-transform: uppercase; margin: 0;
            background: linear-gradient(to bottom, #fff 40%, #555 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 25px rgba(255,255,255,0.3));
        }
        .subtitle {
            font-size: 0.8rem; letter-spacing: 1.2rem; text-transform: uppercase;
            color: #444; margin-top: -5px; font-weight: 300;
        }
        .technique-name {
            margin-top: 30px; font-size: 2.2rem; font-weight: 800; font-style: italic; color: #fff;
            text-shadow: 0 0 40px var(--glow-color, #00f); opacity: 0;
            transform: translateY(20px) scale(0.85); transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .technique-name.active { opacity: 1; transform: translateY(0) scale(1); }

        #camera-container {
            position: absolute; bottom: 30px; right: 30px; width: 220px; height: 165px;
            border-radius: 20px; overflow: hidden; border: 1px solid rgba(255,255,255,0.15);
            background: #000; opacity: 0.8; transform: scaleX(-1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
        }
        #webcam, #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.95) 100%);
            pointer-events: none; z-index: 4;
        }
        #hint {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            font-size: 0.65rem; color: #555; letter-spacing: 4px; text-transform: uppercase;
        }
    </style>
</head>
<body>

    <div id="vignette"></div>
    <div id="ui-overlay">
        <div class="header-group">
            <h1 class="title">プリヤンシュ先生</h1>
            <div class="subtitle">virtual playground for sorceres by PRIYANSHU</div>
            <div id="technique" class="technique-name">RESONATING...</div>
        </div>
        <div id="hint">Focus your Cursed Energy</div>
    </div>

    <div id="camera-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const PARTICLE_COUNT = 180000;
        const LERP_SPEED = 0.06;
        let targetStatus = "NEUTRAL";
        
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const techniqueEl = document.getElementById('technique');

        let scene, camera, renderer, composer, bloomPass;
        let particles, geometry;
        let positions, targetPositions, colors, targetColors, sizes, targetSizes;
        let shakeVal = 0;
        let clock = new THREE.Clock();
        let frameCount = 0;

        const STATES = {
            NEUTRAL: { name: "CURSED RESONANCE", color: "#4488ff", bloom: 0.8, shake: 0, fov: 75 },
            SHRINE: { name: "MALEVOLENT SHRINE", color: "#ff1100", bloom: 2.8, shake: 4.5, fov: 95 },
            WORLD_SLASH: { name: "WORLD CUTTING SLASH", color: "#ffffff", bloom: 0.3, shake: 20.0, fov: 115 },
            VOID: { name: "UNLIMITED VOID", color: "#2244ff", bloom: 2.2, shake: 2.0, fov: 45 },
            RED: { name: "TECHNIQUE REVERSAL: RED", color: "#ff0044", bloom: 10.0, shake: 4.0, fov: 60 },
            BLUE: { name: "TECHNIQUE LAPSE: BLUE", color: "#0066ff", bloom: 10.0, shake: 4.0, fov: 60 },
            PURPLE: { name: "HOLLOW PURPLE", color: "#aa00ff", bloom: 30.0, shake: 50.0, fov: 35 },
            GAMBLE: { name: "IDLE DEATH GAMBLE", color: "#ff00bb", bloom: 6.0, shake: 1.5, fov: 85 },
            SENTENCING: { name: "DEADLY SENTENCING", color: "#ffcc00", bloom: 1.5, shake: 0.5, fov: 65 },
            PERFECTION: { name: "SELF-EMBODIMENT OF PERFECTION", color: "#777777", bloom: 0.8, shake: 5.0, fov: 85 },
            SKANDHA: { name: "CAPTIVATING SKANDHA", color: "#00ffee", bloom: 2.0, shake: 0.5, fov: 105 },
            LOVE: { name: "AUTHENTIC MUTUAL LOVE", color: "#ffffff", bloom: 2.2, shake: 2.5, fov: 80 },
            PROFUSION: { name: "WOMB PROFUSION", color: "#550000", bloom: 1.3, shake: 5.0, fov: 110 },
            PROJECTION: { name: "PROJECTION SORCERY", color: "#00ffcc", bloom: 4.0, shake: 0.0, fov: 75 },
            UZUMAKI: { name: "MAXIMUM: UZUMAKI", color: "#ff4400", bloom: 6.0, shake: 8.0, fov: 90 },
            SERPENT: { name: "COILING SERPENT", color: "#00ff22", bloom: 1.5, shake: 4.0, fov: 90 },
            SOLOIST: { name: "THREEFOLD SOLOIST", color: "#00ff66", bloom: 2.5, shake: 2.0, fov: 75 }
        };

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 4000);
            camera.position.z = 180;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            targetColors = new Float32Array(PARTICLE_COUNT * 3);
            sizes = new Float32Array(PARTICLE_COUNT);
            targetSizes = new Float32Array(PARTICLE_COUNT);

            generateNeutral();
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] = targetPositions[i];
                colors[i] = targetColors[i];
                if(i < PARTICLE_COUNT) sizes[i] = targetSizes[i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({ size: 1.0, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
            initMediaPipe();
            animate();
        }

        function setPalette(r, g, b, varc = 0.25) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const v = (Math.random() - 0.5) * varc;
                targetColors[i*3] = Math.max(0, Math.min(1, r + v));
                targetColors[i*3+1] = Math.max(0, Math.min(1, g + v));
                targetColors[i*3+2] = Math.max(0, Math.min(1, b + v));
                targetSizes[i] = Math.random() * 1.8 + 0.4;
            }
        }

        // --- ENHANCED GEOMETRY GENERATORS ---

        function generateNeutral() {
            setPalette(0.2, 0.5, 1.0, 0.4);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = 60 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                targetPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i*3+2] = r * Math.cos(phi);
            }
        }

        function generatePerfection() {
            // Mahito's Domain: Twisted Hand-clusters and fibers
            setPalette(0.5, 0.5, 0.5, 0.2);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const cluster = Math.floor(i / 1000);
                const angle = cluster * 0.5;
                const r = 30 + Math.sin(cluster) * 50;
                const localX = (Math.random()-0.5) * 20;
                const localY = (Math.random()-0.5) * 20;
                const localZ = (Math.random()-0.5) * 20;
                
                targetPositions[i*3] = r * Math.cos(angle) + localX;
                targetPositions[i*3+1] = (Math.random()-0.5)*300 + localY;
                targetPositions[i*3+2] = r * Math.sin(angle) + localZ;

                if (i % 10 === 0) { // Large hand "tips"
                    targetSizes[i] = 5.0;
                    targetColors[i*3] = 0.9; targetColors[i*3+1] = 0.9; targetColors[i*3+2] = 0.95;
                }
            }
        }

        function generateSkandha() {
            setPalette(0.0, 0.9, 1.0, 0.2);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if(i < PARTICLE_COUNT * 0.7) { // Ocean / Beach surface
                    const x = (Math.random()-0.5)*1200;
                    const z = (Math.random()-0.5)*600;
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = -70 + Math.sin(x * 0.02 + z * 0.02) * 8;
                    targetPositions[i*3+2] = z;
                } else { // Distant Tropical Canopy
                    const angle = Math.random() * Math.PI;
                    const r = 400 + Math.random() * 100;
                    targetPositions[i*3] = r * Math.cos(angle);
                    targetPositions[i*3+1] = 150 + (Math.random()-0.5)*200;
                    targetPositions[i*3+2] = -400;
                }
            }
        }

        function generateUzumaki() {
            setPalette(1.0, 0.3, 0.0, 0.9);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = i / PARTICLE_COUNT;
                const r = t * 180;
                const angle = t * 60;
                targetPositions[i*3] = r * Math.cos(angle);
                targetPositions[i*3+1] = r * Math.sin(angle);
                targetPositions[i*3+2] = (Math.random()-0.5)*100 * (1-t);
                // Dark core
                if (t < 0.1) { targetColors[i*3]=0; targetColors[i*3+1]=0; targetColors[i*3+2]=0; }
            }
        }

        function generateWorldSlash() {
            setPalette(1,1,1,0);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = (Math.random()-0.5)*600;
                targetPositions[i*3] = x;
                targetPositions[i*3+1] = (Math.random()-0.5)*2; // Thin slice
                targetPositions[i*3+2] = (Math.random()-0.5)*5;
                targetSizes[i] = 1.0 + Math.random()*4;
            }
        }

        function generateSoloist() {
            setPalette(0.4, 1.0, 0.6, 0.1);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const wave = Math.floor(i / 1000);
                const x = (wave - 90) * 8;
                const t = (i % 1000) / 1000;
                targetPositions[i*3] = x;
                targetPositions[i*3+1] = Math.sin(x * 0.05 + t * 6.28) * 80;
                targetPositions[i*3+2] = (t - 0.5) * 200;
                if (Math.random() > 0.98) targetSizes[i] = 6.0;
            }
        }

        function generateSerpent() {
            setPalette(0.0, 1.0, 0.3, 0.5);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = i / PARTICLE_COUNT;
                const angle = t * 40;
                const r = 50 + Math.sin(t * 10) * 30;
                targetPositions[i*3] = r * Math.cos(angle);
                targetPositions[i*3+1] = (t - 0.5) * 500;
                targetPositions[i*3+2] = r * Math.sin(angle);
            }
        }

        function generateRed() {
            setPalette(1, 0, 0.2, 0.1);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = 2 + Math.random()*25;
                const t = Math.random()*6.28, p = Math.acos(2*Math.random()-1);
                targetPositions[i*3] = r*Math.sin(p)*Math.cos(t);
                targetPositions[i*3+1] = r*Math.sin(p)*Math.sin(t);
                targetPositions[i*3+2] = r*Math.cos(p);
                targetSizes[i] = 5.0;
            }
        }

        function generateBlue() {
            setPalette(0, 0.5, 1, 0.1);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = 150 + Math.random()*250;
                const t = Math.random()*6.28, p = Math.acos(2*Math.random()-1);
                targetPositions[i*3] = r*Math.sin(p)*Math.cos(t);
                targetPositions[i*3+1] = r*Math.sin(p)*Math.sin(t);
                targetPositions[i*3+2] = r*Math.cos(p);
            }
        }

        // Generic logic for previous ones
        function generateShrine() { setPalette(1,0,0,0.3); for(let i=0; i<PARTICLE_COUNT; i++) { if(i<PARTICLE_COUNT*0.4){ const r=Math.sqrt(Math.random())*120, t=Math.random()*6.28; targetPositions[i*3]=r*Math.cos(t); targetPositions[i*3+1]=-65; targetPositions[i*3+2]=r*Math.sin(t); } else if(i<PARTICLE_COUNT*0.7){ const idx=Math.floor(i/(PARTICLE_COUNT*0.04))%8; targetPositions[i*3]=Math.cos(idx*Math.PI/4)*85; targetPositions[i*3+1]=(Math.random()-0.5)*130; targetPositions[i*3+2]=Math.sin(idx*Math.PI/4)*85; } else { const x=(Math.random()-0.5)*190, z=(Math.random()-0.5)*130; targetPositions[i*3]=x; targetPositions[i*3+1]=70+(x*x)/110; targetPositions[i*3+2]=z; } } }
        function generateVoid() { setPalette(0.1, 0.2, 1, 0.2); for(let i=0; i<PARTICLE_COUNT; i++) { const r=180+Math.random()*350, t=Math.random()*6.28; targetPositions[i*3]=r*Math.cos(t); targetPositions[i*3+1]=(Math.random()-0.5)*450; targetPositions[i*3+2]=r*Math.sin(t); } }
        function generateGamble() { setPalette(1,0,1,0.6); for(let i=0; i<PARTICLE_COUNT; i++) { if(i<PARTICLE_COUNT*0.75){ targetPositions[i*3]=(i%250-125)*2; targetPositions[i*3+1]=(Math.floor(i/250)%250-125)*2; targetPositions[i*3+2]=-120; } else { const r=100+Math.random()*50, t=Math.random()*6.28; targetPositions[i*3]=r*Math.cos(t); targetPositions[i*3+1]=(Math.random()-0.5)*400; targetPositions[i*3+2]=r*Math.sin(t); } } }
        function generateSentencing() { setPalette(0.9, 0.8, 0.2, 0.1); for(let i=0; i<PARTICLE_COUNT; i++) { const a=(Math.random()-0.5)*220, b=(Math.random()-0.5)*220; if(i%3==0){ targetPositions[i*3]=a; targetPositions[i*3+1]=-90; targetPositions[i*3+2]=b; } else if(i%3==1){ targetPositions[i*3]=a; targetPositions[i*3+1]=b; targetPositions[i*3+2]=-160; } else { targetPositions[i*3]=(i%2==0?-75:75); targetPositions[i*3+1]=50; targetPositions[i*3+2]=0; } } }
        function generateLove() { setPalette(1,1,1,0); for(let i=0; i<PARTICLE_COUNT; i++) { targetPositions[i*3]=(Math.random()-0.5)*350; targetPositions[i*3+1]=-90+Math.random()*150; targetPositions[i*3+2]=(Math.random()-0.5)*350; } }
        function generateProfusion() { setPalette(0.5, 0, 0, 0.8); for(let i=0; i<PARTICLE_COUNT; i++) { const t=i/PARTICLE_COUNT, a=t*220, r=45+Math.sin(t*25)*25; targetPositions[i*3]=r*Math.cos(a); targetPositions[i*3+1]=(t-0.5)*450; targetPositions[i*3+2]=r*Math.sin(a); } }
        function generateProjection() { setPalette(0,1,0.9,0.2); for(let i=0; i<PARTICLE_COUNT; i++) { const s=Math.floor(i/(PARTICLE_COUNT/24)); targetPositions[i*3]=(s%6-2.5)*70+(Math.random()-0.5)*60; targetPositions[i*3+1]=(Math.floor(s/6)-1.5)*70+(Math.random()-0.5)*60; targetPositions[i*3+2]=0; } }
        function generatePurple() { setPalette(0.6,0,1,0.7); for(let i=0; i<PARTICLE_COUNT; i++) { const c=i<PARTICLE_COUNT*0.9, r=c?Math.random()*25:60+Math.random()*500; const t=Math.random()*6.28, p=Math.acos(2*Math.random()-1); targetPositions[i*3]=r*Math.sin(p)*Math.cos(t); targetPositions[i*3+1]=r*Math.sin(p)*Math.sin(t); targetPositions[i*3+2]=r*Math.cos(p); if(c) targetSizes[i]=5; } }

        function switchState(key) {
            if (targetStatus === key) return;
            targetStatus = key;
            const cfg = STATES[key];
            techniqueEl.classList.remove('active');
            setTimeout(() => { techniqueEl.innerText = cfg.name; techniqueEl.style.setProperty('--glow-color', cfg.color); techniqueEl.classList.add('active'); }, 50);
            bloomPass.strength = cfg.bloom; shakeVal = cfg.shake;

            if(key==="NEUTRAL") generateNeutral(); else if(key==="SHRINE") generateShrine(); else if(key==="VOID") generateVoid();
            else if(key==="GAMBLE") generateGamble(); else if(key==="SENTENCING") generateSentencing(); else if(key==="LOVE") generateLove();
            else if(key==="PROFUSION") generateProfusion(); else if(key==="PROJECTION") generateProjection(); else if(key==="PURPLE") generatePurple();
            else if(key==="PERFECTION") generatePerfection(); else if(key==="SKANDHA") generateSkandha(); else if(key==="WORLD_SLASH") generateWorldSlash();
            else if(key==="UZUMAKI") generateUzumaki(); else if(key==="RED") generateRed(); else if(key==="BLUE") generateBlue();
            else if(key==="SERPENT") generateSerpent(); else if(key==="SOLOIST") generateSoloist();
        }

        function onResults(results) {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                const h1 = hands[0];
                const isUp = (h, i) => h[i].y < h[i-2].y;
                const getDist = (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2);

                if (hands.length === 2) {
                    const h2 = hands[1];
                    const tipDist = getDist(h1[8], h2[8]);
                    const palmDist = getDist(h1[0], h2[0]);
                    if (tipDist < 0.05) switchState("PURPLE");
                    else if (palmDist < 0.08) switchState("PERFECTION");
                    else if (isUp(h1, 8) && isUp(h2, 8) && isUp(h1, 12) && isUp(h2, 12)) switchState("VOID");
                    else if (isUp(h1, 8) && isUp(h2, 8)) switchState("SOLOIST");
                    else switchState("GAMBLE");
                } else {
                    const indexUp = isUp(h1, 8), middleUp = isUp(h1, 12), ringUp = isUp(h1, 16), pinkyUp = isUp(h1, 20);
                    const thumbUp = h1[4].x < h1[2].x;
                    const isPinch = getDist(h1[4], h1[8]) < 0.05;

                    if (isPinch) switchState("SHRINE");
                    else if (thumbUp && pinkyUp && !indexUp) switchState("SKANDHA");
                    else if (indexUp && middleUp && ringUp && pinkyUp) switchState("SENTENCING");
                    else if (indexUp && middleUp && !ringUp) switchState("PROJECTION");
                    else if (pinkyUp) switchState("UZUMAKI");
                    else if (indexUp && !middleUp) switchState("BLUE");
                    else if (middleUp && !indexUp) switchState("RED");
                    else if (h1[8].y > h1[0].y) {
                        if (getDist(h1[4], h1[20]) < 0.05) switchState("WORLD_SLASH");
                        else switchState("PROFUSION");
                    }
                    else if (middleUp && ringUp) switchState("SERPENT");
                    else switchState("NEUTRAL");
                }
            } else switchState("NEUTRAL");
        }

        async function initMediaPipe() {
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.85, minTrackingConfidence: 0.8 });
            hands.onResults(onResults);
            new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480 }).start();
        }

        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            frameCount++;
            if (targetStatus === "PROJECTION" && frameCount % 3 !== 0) return;
            
            camera.fov += (STATES[targetStatus].fov - camera.fov) * 0.06;
            camera.updateProjectionMatrix();

            const posArr = geometry.attributes.position.array, colArr = geometry.attributes.color.array, sizArr = geometry.attributes.size.array;
            const lv = targetStatus === "PROJECTION" ? 1.0 : LERP_SPEED;
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                posArr[i] += (targetPositions[i] - posArr[i]) * lv;
                colArr[i] += (targetColors[i] - colArr[i]) * lv;
                if(i < PARTICLE_COUNT) sizArr[i] += (targetSizes[i] - sizArr[i]) * lv;
            }

            if(targetStatus==="PURPLE") { particles.rotation.y += 0.8; particles.scale.setScalar(1+Math.sin(t*60)*0.25); }
            else if(targetStatus==="UZUMAKI") { particles.rotation.z += 0.5; }
            else if(targetStatus==="SHRINE") { particles.rotation.y += 0.03; }
            else if(targetStatus==="PERFECTION") { particles.rotation.y += 0.002; particles.position.x = Math.sin(t)*10; }
            else if(targetStatus==="WORLD_SLASH") { particles.position.x = (Math.random()-0.5)*5; }
            else particles.rotation.y += 0.005;

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;
            if (shakeVal > 0) renderer.domElement.style.transform = `translate(${(Math.random()-0.5)*shakeVal}px, ${(Math.random()-0.5)*shakeVal}px)`;
            else renderer.domElement.style.transform = `none`;
            composer.render();
        }

        async function loadScript(src) { return new Promise((res) => { const s = document.createElement('script'); s.src = src; s.onload = res; document.head.appendChild(s); }); }
        (async () => {
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js");
            init();
        })();
    </script>
</body>
</html>
